---
layout: post
title: "Modern C++ on the ESP32: how I use it and why it may make sense"
---

In this post, I will talk about my daily experience with (modern) C++ on the ESP32, and why it may have finally become a good choice for reliable, complex applications running on low power devices.

As the adage goes, nowadays most often than not the most expensive resource in software development is your developers' time, especially since modern chips have become so beefy that they can somewhat crunch away most of the inefficiency that plagued the software from yesteryear. An area where this is not is generally not the case is embedded and ultra low power applications, a wild land where free memory is still measured in Kilobyte (pardon, Kibibyte), "garbage collection" is a bad word, and patching and updating are still a somewhat cumbersome and complex task.

While the world hasn't stood still at all in recent years, with inexpensive SoCs getting faster and faster at lower prices, I think is not wrong to say that the success of an embedded project still revolves around making the right compromises and picking the right tools for the job. 

### ESP32: a quick overview

The ESP32 is an embedded platform designed and built by Chinese manufacturer Espressif which has built a lot of buzz in recent years thanks to it being quite feature-rich at a ridiculously low price point. It packs a wide array of interesting specs on a single compact SoC, including a dual-core 32-bit Xtensa CPU that runs up to 240 MHz, a ULP coprocessor, ~ 1/2 MiB of internal RAM, 2.4 GHz WiFi, Bluetooth (including BLE), a wide array of interfaces (SPI, I2C, I2S, UART, CAN, GPIOs, ... ) and a good amount of integrated SPI-connected Flash (in several sizes from 2 to 16 MiB). 
The ESP32 is usually embedded in circuits using off the shelf surface-mounted modules, usually branded as either WROOM or WROVER. These two families mostly differ by the inclusion of a built-in SPI-connected pSRAM module (or the lack thereof), an addition that vastly expands its versatility and usefulness for complex applications. This RAM is directly mapped to the main address space, and it's this available to programs directly through normal static or malloc-allocated variables. [^1]

The addition of SPIRAM comes however with a few (arguably acceptable) drawbacks, including it being slower than built-in DRAM (it's connected through a shared SPI bus after all) and adding yet another type of RAM that needs special handling during development [^2][^3]. 

### Programming 

C++ hasn't exactly the best rap among languages for embedded chips.

It surely hasn't the "cult" status of C, which in its simplicity it's powerful, yet hard to master, and until a short time ago still considered too expensive for certain boards where only Assembly would do. 

Surely, it hasn't the hip factor of younger, arguably less crufty languages like Zig or Rust, whose guarantees of safety and stability sound extremely promising when you don't have a "real" OS to fall back on you up when you screw up.

I have personally spent the last few years studying Rust, and I do believe it (and its brethren, for what counts) presents a nice solution to several structural issues that systematically trouble system development, and that the approach of tackling issues such as memory management and data races as language issues, instead of relegating them to the programmer's good judgment is (probably) the correct one.

Unfortunately, despite all the work done in recent years, using Rust instead of C and C++ is sometimes still harder than I'd like. In the case of the ESP32, both support and mindshare are still not there; there's however some work being done by both Espressif, with its LLVM/Clang Xtensa port, and the community, which has been running Rust on this out-of-tree experimental target for quite some time.

The revisions after C++11 have vastly improved the language, introducing many big features that dramatically changed how people are supposed to write code, throwing away decades of well-established code practices and making it arguably harder and more confusing for novice developers.
Despite these drawbacks, these changes have made the language much more expressive, and by picking the right features and following sane guidelines (such as the GSL) it's possible to write safe, strongly-typed code capable to provide much stronger guarantees than what it was previously possible.

### C++ on the ESP32

Espressif provides a somewhat _POSIXish_ development framework for the ESP32 called ESP-IDF, which provides basically the entire environment around which applications for the ESP32 are built. This goes from providing basic primitives such as task management (based on FreeRTOS) to modules to control hardware devices, to access the flash, to a memory allocator, and so on. 

The only supported toolchain is GNU; the currently supported GCC version (at the time of writing this) is 8.4.0, which is almost completely C++17 compliant.

It now follows a quick breakdown of what I've been using and what I think should be avoided if you plan, like me, to write complex C++ applications targeting the ESP32.

#### System libraries

Most (but not all) of IDF is written in plain C; it's thus necessary to often interoperate with libraries that might not have been designed with C++ in mind when written, writing shims when needed. 
libstdc++ from GCC has been surprisingly feature-complete and stable, with Espressif clearly devoting some time to ensure it worked correctly and without too much fuss. This allows most of the C++ libraries out there to work out of the box on the ESP32, as long as they've been designed to be portable in the first place. The CPU itself is 32 bit and little-endian like ARM or x86, thus eliminating two of the most common causes of incompatibility in my experience.

### In conclusion

[^1]: This is only true for the first 4 MiBs of SPIRAM. In order to access more than that amount, some good old bank-switching magic is required.
[^2]: Most people (and programming languages) are accustomed to a memory model where all RAM is directly addressable, and every chunk is somewhat equal to another. This is often not the case in embedded applications: for instance, the ESP32's builtin memory is segmented in several areas, each one with different capabilities (8-bit addressable,32-bit addressable IRAM, static RTC memory, DMA-capable, etc), and the integrated MMU is too rudimental to help. This obviously increases the complexity of managing memory allocations, due to different peripherals and functionalities requiring different kinds of RAM.
[^3]: SPIRAM is also somewhat buggy in older chip revisions; this problem has somewhat mitigated by newer hardware and toolchain workarounds, but it's still a severe PITA when targetting older boards.